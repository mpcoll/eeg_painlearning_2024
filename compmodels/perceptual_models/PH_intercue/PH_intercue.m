function [traj, infStates] = PH_intercue(r, p, varargin)
% MODIFIED HGF TOOLBOX FUNCTION BY MP COLL, 2019 for FEAR COND EXPERIMENT

% Calculates the trajectories of v under the Rescorla-Wagner learning model

% Based on tapas_binary_PH by
% Copyright (C) 2012-2013 Christoph Mathys, TNU, UZH & ETHZ
% This function can be called in two ways:
%
% (1) tapas_rw_binary(r, p)
%
%     where r is the structure generated by tapas_fitModel and p is the parameter vector in native space;
%
% (2) tapas_rw_binary(r, ptrans, 'trans')
%
%     where r is the structure generated by tapas_fitModel, ptrans is the parameter vector in
%     transformed space, and 'trans' is a flag indicating this.
%
% --------------------------------------------------------------------------------------------------
%
% This file is part of the HGF toolbox, which is released under the terms of the GNU General Public
% Licence (GPL), version 3. You can redistribute it and/or modify it under the terms of the GPL
% (either version 3 or, at your option, any later version). For further details, see the file
% COPYING or <http://www.gnu.org/licenses/>.

% Transform paramaters back to their native space if needed
if ~isempty(varargin) && strcmp(varargin{1},'trans')
    p = PH_intercue_transp(r, p);
end

% Unpack parameters
v_0 = p(1);
al  = p(2);
a_0 = p(3);
ga = p(4);
al2 = al;
ga2 = ga;

% Get outcomes
d.shock = r.u(:,1);

% Get cue presented
d.cuenum = r.u(:, 2);

% Number of cues (or # of independent HGF)
nc = length(unique(d.cuenum));
d.trials = length(d.cuenum);
trials = d.trials;
% Initiate trajectories
traj = struct;
traj.v = NaN(d.trials, 1);
traj.vhat = NaN(d.trials, 1);
traj.da = NaN(d.trials, 1);
traj.a = NaN(d.trials, 1);


for c = 1:nc
    pred.cue(c).v = v_0;
    pred.cue(c).a = a_0;
    seencues(c) = 0; % Init array of seen cues with 0
end

for t = 1:d.trials% Loop trials

    % Find cue presented
    cue = d.cuenum(t);

    % Get cues not presented
    othercues = 1:nc;
    othercues(cue) = [];

    % Mark current cue as seen
    seencues(cue) = 1;

    % RW model with 1 LR

    v(t) = pred.cue(cue).v; % Get current expectation, take out for brievty
    a(t) = pred.cue(cue).a; % Get current expectation, take out for brievty
    da(t) = d.shock(t) - v(t); % calculate pe

    pred.cue(cue).v = v(t) + al * da(t) * a(t); % Get updated expectancy
    pred.cue(cue).a = ga * abs(da(t)) + (1 - ga) * a(t); % Get updated associativity


    if d.shock(t)% Update others only if shock because no shock is not informative of other cues???
        % Update seen but not presented cues (NOT SURE)
 
        for o = othercues% Loop all unpresented cue
            if seencues(o) == 1% Update only seen cues
                pe_unpresented = not(d.shock(t)) - pred.cue(o).v; % calculate pe
                % Get updated expectancy
                pred.cue(o).v = pred.cue(o).v + al2 * pe_unpresented * pred.cue(o).a; % Store for this cue
                pred.cue(o).a = ga2 * abs(pe_unpresented) + (1 - ga2) * pred.cue(o).a;% Get updated associativity
             end

        end
    end

end

% Store in data structure
traj.v = v;
traj.vhat = v;
traj.da = da;
traj.a = a;

% Create matrix (in this case: vector) needed by observation model
infStates = [traj.v', traj.a'];

return;

function [traj, infStates] = PH_nointercue(r, p, varargin)
% MODIFIED HGF TOOLBOX FUNCTION BY MP COLL, 2019 for FEAR COND EXPERIMENT

% Calculates the trajectories of v under the Rescorla-Wagner learning model

% Based on tapas_binary_PH by
% Copyright (C) 2012-2013 Christoph Mathys, TNU, UZH & ETHZ
% This function can be called in two ways:
%
% (1) tapas_rw_binary(r, p)
%
%     where r is the structure generated by tapas_fitModel and p is the parameter vector in native space;
%
% (2) tapas_rw_binary(r, ptrans, 'trans')
%
%     where r is the structure generated by tapas_fitModel, ptrans is the parameter vector in
%     transformed space, and 'trans' is a flag indicating this.
%
% --------------------------------------------------------------------------------------------------
%
% This file is part of the HGF toolbox, which is released under the terms of the GNU General Public
% Licence (GPL), version 3. You can redistribute it and/or modify it under the terms of the GPL
% (either version 3 or, at your option, any later version). For further details, see the file
% COPYING or <http://www.gnu.org/licenses/>.

% Transform paramaters back to their native space if needed
if ~isempty(varargin) && strcmp(varargin{1},'trans')
    p = PH_nointercue_transp(r, p);
end

% Unpack parameters
v_0 = p(1);
al  = p(2);
a_0 = p(3);
ga = p(4);

% Get outcomes
u = r.u(:,1);

% Get cue presented
c = r.u(:, 2);

% Number of cues (or # of independent HGF)
nc = max(c);
trials = length(c);

% Initiate trajectories
traj = struct;
traj.v = NaN(trials, 1);;
traj.vhat = NaN(trials, 1);;
traj.da = NaN(trials, 1);;
traj.a = NaN(trials, 1);;

% Run the model for each cue
for cue = 1:nc

    % trials for this cue
    ctrials = find(c == cue);

    % cue specific reinforcement
    o = u(c == cue);

    % Number of trials for thsi cue
    n = length(o);

    % Initialize updated quantity: value
    v  = NaN(n, 1);
    da = NaN(n, 1);
    a = NaN(n, 1);

    % Prior
    v(1) = v_0;
    a(1) = a_0;

    % Pass through value update loop for this cue
    for k = 1:n
    
        % Prediction error
        da(k) = o(k)-v(k);
    
        % Update v and a
        v(k+1) = v(k)  + al * da(k) * a(k);

        a(k+1) = ga * abs(da(k)) + (1 - ga) * a(k);
    
    end
    
    % Remove extra trials
    a(end) = [];
    v(end) = [];
    vhat = v; 

    % Assigne cue specific trials to trials structure
    traj.v(ctrials, :) = v;
    traj.vhat(ctrials, :) = vhat;
    traj.da(ctrials, :) = da;
    traj.a(ctrials, :) = a;

end
% Create matrix (in this case: vector) needed by observation model
infStates = [traj.vhat, traj.a];

return;
